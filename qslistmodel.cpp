/* QSyncable Project
   Author: Ben Lau
   License: Apache-2.0
   Web: https://github.com/benlau/qsyncable
*/
#include <QtCore>
#include "qslistmodel.h"


/*! \class QSPatchable
    \inmodule QSyncable

  QSPatchahble is an interface for classes that could apply the patches generated by QSDiffRunner. (e.g QSListModel)
 */

/*! \fn  void QSPatchable::insert(int index, const QVariantList &value)

    Inserts value at index position in the list model.
 */

/*! \fn void QSPatchable::move(int from, int to, int n)

    Moves n items from one position to another.
 */

/*! \fn  void QSPatchable::remove(int i , int count = 1);

    Deletes the content at index from the model. You may specific the no. of items to be removed by count argument.
 */

/*! \fn  void QSPatchable::set(int index, QVariantMap changes) = 0;

    Changes the item at index in the list model with the values in changes. Properties not appearing in changes are left unchanged.

    If index is equal to count() then a new item is appended to the list. Otherwise, index must be an element in the list.
 */

/*! \class QSListModel
   \inmodule QSyncable

QSListModel is an implementation of QAbstactItemModel.
It stores data in a list of QVariantMap.
Moreover, it has implemented the QSPatchable interface.
You may use QSDiffRunner to patch QSListModel,
and it will emit insert, remove, move and data changed signals according to the patch applied.

 */

QSListModel::QSListModel(QObject *parent) :
    QAbstractListModel(parent)
{
}

/*! \fn int QSListModel::rowCount(const QModelIndex &parent) const

  Returns no. of items in this list model
 */

int QSListModel::rowCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent)
    return count();
}

/*! \fn QVariant QSListModel::data(const QModelIndex &index, int role) const

  Returns the data stored under the given role for the item referred to by the index.

  Note: If you do not have a value to return, return an invalid QVariant instead of returning 0.
 */
QVariant QSListModel::data(const QModelIndex &index, int role) const
{
    if (index.row() < 0 || index.row() >= m_storage.size())
        return QVariant();

    QVariant v;

    if (m_roles.contains(role)) {
        QVariantMap item = m_storage.at(index.row()).toMap();
        v = item[m_roles[role]];
    }

    return v;
}

/*! \fn bool QSListModel::setData(const QModelIndex &index, const QVariant &value, int role)

Sets the role data for the item at index to value.
Returns true if successful; otherwise returns false.
The dataChanged() signal should be emitted if the data was successfully set.
 */
bool QSListModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
    if (index.row() < 0 || index.row() >= m_storage.size())
            return false;

    if (!m_roles.contains(role))
    {
        return false;
    }

    auto item = m_storage[index.row()].toMap();

    if(item[m_roles[role]] == value)
    {
        // value was already correct, no need to update / emit change signal.
        return true;
    }

    item[m_roles[role]] = value;
    m_storage[index.row()] = item;
    emit dataChanged(index, index, {role});
    return true;
}

/*! \fn void QSListModel::append(const QVariantMap &value)

  Append an items at the end of list

 */

void QSListModel::append(const QVariantMap &value)
{
    if (m_roles.isEmpty()) {
        setRoleNames(value);
    }

    beginInsertRows(QModelIndex(),m_storage.size(),m_storage.size());
    m_storage.append(value);
    endInsertRows();
    emit countChanged();
}

/*! \fn  void QSListModel::insert(int index,const QVariantMap& value);

  Inserts an item at index position.

 */
void QSListModel::insert(int index, const QVariantMap &value)
{
    if (m_roles.isEmpty()) {
        setRoleNames(value);
    }

    beginInsertRows(QModelIndex(), index, index);
    m_storage.insert(index, value);
    endInsertRows();
    emit countChanged();
}

/*! \fn void QSListModel::insert(int index, const QVariantList &value)

    Returns the index position of the first occurrence of the byte array ba in this byte array,
 */
void QSListModel::insert(int index, const QVariantList &value)
{
    if (value.count() == 0) {
        return;
    } else if (value.count() == 1) {
        insert(index, value.at(0).toMap());
        return;
    }

    if (m_roles.isEmpty()) {
        setRoleNames(value.at(0).toMap());
    }

    beginInsertRows(QModelIndex(), index, index + value.count() - 1);
    m_storage.reserve(m_storage.count() + value.count());

    QVariantList mid = m_storage.mid(index);

    for (int i = 0 ; i < value.size() ; i++) {
        if (index + i < m_storage.size()) {
            m_storage[index + i] = value.at(i);
        } else {
            m_storage.append(value.at(i));
        }
    }

    for (int i = 0; i < mid.size(); i++) {
        int idx = index + value.size() + i;
        if (idx < m_storage.count()) {
            m_storage[idx] = mid.at(i);
        } else {
            m_storage.append(mid.at(i));
        }
    }

    endInsertRows();
    emit countChanged();
}

/*! \fn void QSListModel::move(int from, int to, int n)

    Moves n items from one position to another.
 */

void QSListModel::move(int from, int to, int count)
{

    if (from > to) {
        int f = from;
        int t = to;
        int c = count;
        count = f - t;
        from = t;
        to = t + c;
    }

    if (count <= 0 ||
        from == to ||
        from + count > m_storage.count() ||
        to + count > m_storage.count() ||
        from < 0 ||
        to < 0) {
        return;
    }

    beginMoveRows(QModelIndex(), from, from + count - 1,
                  QModelIndex(), to > from ? to + count : to);

    QVariantList tmp;
    tmp.reserve(to - from + count);

    // Move "to" block
    for (int i=0 ; i < (to - from) ; i++) {
        tmp.append(m_storage[from + count + i]);
    }

    // Move "from" block
    for (int i = 0 ; i < count ; i++) {
        tmp.append(m_storage[from + i]);
    }

    // Replace
    for (int i=0 ; i < tmp.count() ; ++i) {
        m_storage[from + i] = tmp[i];
    }

    endMoveRows();
}

/*! \fn void QSListModel::clear()

  Clear the content of list model.

 */

void QSListModel::clear()
{
    if (m_storage.isEmpty())
        return;

    beginRemoveRows(QModelIndex(), 0, m_storage.count() - 1);
    m_storage.clear();
    endRemoveRows();
    emit countChanged();

}

/*! \fn  void QSListModel::remove(int i , int count = 1);

    Deletes the content at index from the model. You may specific the no. of items to be removed by count argument.
 */

void QSListModel::remove(int i, int count)
{
    if (count < 1 || i + count > m_storage.size()) {
        return;
    }
    beginRemoveRows(QModelIndex(), i, i + count - 1);
    for (int j = 0; j < count; ++j) {
        m_storage.removeAt(i);
    }
    endRemoveRows();
    emit countChanged();
}

/*! \property QSListModel::count

    No. of items in this list model.

 */

/*! \fn int QSListModel::count() const

    Returns no. of items in this list model.

 */
int QSListModel::count() const
{
    return m_storage.size();
}

/*! \fn QVariantMap QSListModel::get(int i) const

    Returns the item at index in the list model.
 */

QVariantMap QSListModel::get(int i) const
{
    QVariantMap map;
    if (i >=0 && i < m_storage.size()) {
        map = m_storage.at(i).toMap();
    }
    return map;

}

/*! \fn  void QSListModel::setProperty(int idx, QString property, QVariant value)

    Apply the changes to a record at index. Only modified value will be set.
 */

void QSListModel::setProperty(int idx, QString property, QVariant value)
{
    if (idx < 0 || idx >= m_storage.size())
        return;

    QVector<int> roles;
    QVariantMap item = get(idx);

    QHashIterator<int, QByteArray> i(m_roles);
    while (i.hasNext()) {
        i.next();
        if (i.value() == property) {
            roles << i.key();
            break;
        }
    }

    item[property] = value;

    m_storage[idx] = item;

    emit dataChanged(index(idx,0),
                     index(idx,0),
                     roles);
}

void QSListModel::set(int idx, QVariantMap data)
{
    if (idx < 0 || idx > m_storage.size()) {
        return;
    }

    if (idx == m_storage.size()) {
        append(data);
        return;
    }

    QVector<int> roles;

    QVariantMap original = get(idx);

    QMapIterator<QString, QVariant> iter(data);

    while (iter.hasNext()) {
        iter.next();
        if (!original.contains(iter.key()) ||
                original[iter.key()] != iter.value()) {

            if (m_rolesLookup.contains(iter.key())) {
                roles << m_rolesLookup[iter.key()];
            }

            original[iter.key()] = iter.value();
        }
    }

    m_storage[idx] = original;

    emit dataChanged(index(idx,0),
                     index(idx,0),
                     roles);
}

/*! \fn QHash<int, QByteArray> QSListModel::roleNames() const

  Returns the model's role names.
 */
QHash<int, QByteArray> QSListModel::roleNames() const
{
    return m_roles;
}

/*! \fn void QSListModel::setRoleNames(const QVariantMap &value)

Sets the model's role names to roleNames.

This function allows mapping of role identifiers to role property names in scripting languages.
*/

void QSListModel::setRoleNames(const QVariantMap &value)
{
    m_roles.clear();
    m_rolesLookup.clear();

    QMapIterator<QString,QVariant> iter(value);

    int role = Qt::UserRole;

    while (iter.hasNext()) {
        iter.next();
        m_roles[role] = iter.key().toLocal8Bit();
        m_rolesLookup[iter.key()] = role++;
    }
}

/*! \fn void QSListModel::setRoleNames(const QStringList& list)

Sets the model's role names to roleNames.

This function allows mapping of role identifiers to role property names in scripting languages.
*/

void QSListModel::setRoleNames(const QStringList& list)
{
    m_roles.clear();
    m_rolesLookup.clear();

    int role = Qt::UserRole;

    for (int i = 0 ; i < list.size();i++) {
        QString name = list.at(i);
        m_roles[role] = name.toLocal8Bit();
        m_rolesLookup[name] = role++;
    }
}

/*! \fn void QSListModel::setStorage(const QVariantList &value)

  Replace the content of this list model by input value.
 */

void QSListModel::setStorage(const QVariantList &value)
{
    if (m_roles.isEmpty() && value.size() > 0) {
        setRoleNames(value.at(0).toMap());
    }

    int oldCount = m_storage.count();
    beginResetModel();
    m_storage = value;
    endResetModel();
    if (oldCount != m_storage.size()) {
        emit countChanged();
    }
}

/*! \fn QVariantList QSListModel::storage() const

Get the content ot this list model

 */
QVariantList QSListModel::storage() const
{
    return m_storage;
}

/*! \fn int QSListModel::indexOf(QString field, QVariant value) const

Returns the index position of the first occurrence of the item with field equal to value
 */

int QSListModel::indexOf(QString field, QVariant value) const
{
    int res = -1;
    for (int i = 0 ; i < m_storage.count();i++) {
        QVariantMap item = m_storage.at(i).toMap();
        if (item.contains(field) && item[field] == value) {
            res = i;
            break;
        }
    }
    return res;
}

